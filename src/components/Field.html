<svg class="container overflow-visible">
  <g>
    <rect
      width="{{canvas.width}}"
      height="{{canvas.height}}"
      x="{{canvas.x}}"
      y="{{canvas.y}}"
      style="fill:{{canvas.background}}"
    />
  {{#each field as row, y}}
    {{#each row as cell, x}}
      <rect
        on:click="click({x, y})"
        :width :height
        x="{{cell.x + gap}}" y="{{cell.y + gap}}"
        id="cell{{x}}x{{y}}" style="fill:{{cell.color}}"
      />
    {{/each}}
  {{/each}}
  </g>
</svg>
<FieldDebug
  ref:debug
  :X
  :Y
  :cellsize
  :gap
  :width
  :height
  :interval
  :running
/>
<style>
  svg {
    position: absolute;
    right: 800px;
  }

  .overflow-visible {
    overflow: visible;
  }

  .container {
    display: flex;
  }
</style>
<script type="buble">
import FieldDebug from './FieldDebug.html'

import {
  algorithm,
  background,
  createField,
  randomMatrix,
  step,
  cellstate,
  colors
} from '../modules/matrix'

import {
  parseUnsignedInt as parse,
  spacing,
} from '../modules/utils'

import { moore } from '../modules/matrix/neighborhood'

const frequency = 1 // Hz

const canvasParams = (cellsize, x, y, gap) => {
  return {
    background,
    width: cellsize * x + gap,
    height: cellsize * y + gap,
    x: 0,
    y: 0
  }
}

export default {
  oncreate () {
    const initialMatrix = (X, Y) =>
      this.set({
        matrix: randomMatrix(colors.length)(X, Y)
      })
    // TODO refactor matrix initialization
    this.refs.debug.observe('X', (X) => { this.set({ X }); initialMatrix(X, this.get('Y'))})
    this.refs.debug.observe('Y', (Y) => { this.set({ Y }); initialMatrix(this.get('X'), Y)})

    this.refs.debug.observe('height', (height) => this.set({ height }))
    this.refs.debug.observe('width', (width) => this.set({ width }))
    this.refs.debug.observe('cellsize', (cellsize) => this.set({ cellsize }))
    this.refs.debug.observe('gap', (gap) => this.set({ gap }))
    this.refs.debug.observe('interval', (interval) => this.set({ interval }))
    this.refs.debug.observe('running', (running) => this.set({ running }))

    const interval = 1 / frequency * 1000
    this.set({ interval })
    console.log(`Running simulation at ~${frequency} Hz`)

    const neighborhood = moore(1)()
    // TODO extract this function and use a callback to update intervals
    const updateMatrix = () => {
      if (this.get('running')) {
        const dimension = { X: this.get('X'), Y: this.get('Y') }
        console.log('step for matrix')
        const matrix = step(this.get('matrix'), {
          neighborhood, dimension, algorithm,
          states: colors.length })
        this.set({ matrix })
      }
    }

    this.set({ loopHandler: setInterval( updateMatrix, this.get('interval')) });
  },

  ondestroy () {
    clearInterval( this.interval );
  },

  data () {
    const field = { matrix: [] }

    return {
      running: false,
      loopHandler: null,
      interval: 1,
      X: 64,
      Y: 64,
      gap: 1,
      cellsize: 15,
      matrix: [],
      field
    }
  },
  computed: {
    gap: (gap) => parse(gap),
    field: (X, Y, cellsize, gap, matrix) => {
      return createField(colors, matrix, X, Y, cellsize, gap)
    },
    width: (cellsize, gap) =>
      spacing(parse(cellsize), parse(gap)),
    height: (cellsize, gap) =>
      spacing(parse(cellsize), parse(gap)),
    canvas: (cellsize, X, Y, gap) =>
      canvasParams(parse(cellsize), parse(X), parse(Y), parse(gap)),
    X: X => parse(X),
    Y: Y => parse(Y),
  },
  components: {
    FieldDebug
  },
  methods: {
    click: function ({x, y}) {
      console.log(`clicked on x: ${x} y: ${y}`)
      const matrix = this.get('matrix')
      const dimension = { X: this.get('X'), Y: this.get('Y') }
      this.set({
        matrix:
        cellstate(
          matrix,
          dimension,
          { x, y },
          state => (state + 1) % colors.length
        )
      })
    }
  }
}
</script>
