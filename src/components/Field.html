<svg class="container overflow-visible">
  <g>
    <rect
      width="{{canvas.width}}"
      height="{{canvas.height}}"
      x="{{canvas.x}}"
      y="{{canvas.y}}"
      style="fill:{{backgroundcolor}}"
    />
  {{#each field as row, y}}
    {{#each row as cell, x}}
      <rect
        on:click="click({x, y})"
        :width :height
        x="{{cell.x + gap}}" y="{{cell.y + gap}}"
        id="cell{{x}}x{{y}}" style="fill:{{cell.color}}"
      />
    {{/each}}
  {{/each}}
  </g>
</svg>
<div class="bottom-right">
  <button on:click="next()" value="next" >next</button>
  <button on:click="save()" value="save" >save</button>
  <button on:click="load()" value="load" >load</button>
</div>
<FieldDebug
  ref:debug
  :X
  :Y
  :cellsize
  :gap
  :width
  :height
  :interval
  :running
/>
<style>
  svg {
    position: absolute;
    right: 800px;
  }

  .overflow-visible {
    overflow: visible;
  }

  .container {
    display: flex;
  }

  .bottom-right {
    position: absolute;
    right: 0;
    bottom: 0;
  }
</style>
<script>
import FieldDebug from './FieldDebug.html'

import {
  algorithms,
  createField,
  randomMatrix,
  step,
  cellstate,
  colormap,
} from '../modules/matrix'

import {
  parseUnsignedInt as parse,
  spacing,
} from '../modules/utils'

import {
  extractHSLColorComponents,
  toHSL,
  rotateHue,
} from '../modules/color'

import { moore } from '../modules/matrix/neighborhood'

const { method: algorithm } = algorithms[0]
const algos = algorithms.map(({name}) => name)
console.log(algos)
const { states, background: backgroundcolor } = colormap.hsl

const frequency = 10 // Hz

const canvasParams = (cellsize, x, y, gap) => {
  return {
    width: cellsize * x + gap,
    height: cellsize * y + gap,
    x: 0,
    y: 0
  }
}

const shapePropsForNextStep = (matrix, X, Y, neighborhood, algorithm, states) => [
  matrix,
  {
    dimension: {
      X,
      Y,
    },
    neighborhood,
    algorithm,
    states
  }
]

let matrixState = []
const saveMatrixState = (ref) => {
  matrixState = ref.get('matrix')
}

const loadMatrixState = (ref) => {
  ref.set({ matrix: matrixState })
}

export default {
  oncreate () {
    const initialMatrix = (X, Y) =>
      this.set({
        matrix: randomMatrix(states.length)(X, Y)
      })
    // TODO refactor matrix initialization
    this.refs.debug.observe('X', (X) => { this.set({ X }); initialMatrix(X, this.get('Y')) })
    this.refs.debug.observe('Y', (Y) => { this.set({ Y }); initialMatrix(this.get('X'), Y) })

    this.refs.debug.observe('height', (height) => this.set({ height }))
    this.refs.debug.observe('width', (width) => this.set({ width }))
    this.refs.debug.observe('cellsize', (cellsize) => this.set({ cellsize }))
    this.refs.debug.observe('gap', (gap) => this.set({ gap }))
    this.refs.debug.observe('interval', (interval) => this.set({ interval }))
    this.refs.debug.observe('running', (running) => this.set({ running }))

    const interval = 1 / frequency * 1000
    this.set({ interval })
    console.log(`Running simulation at ~${frequency} Hz`)

    const neighborhood = moore(1)()

    // TODO extract this function and use a callback to update intervals
    const updateMatrix = () => {
      const [matrix, options] = shapePropsForNextStep(
        this.get('matrix'),
        this.get('X'),
        this.get('Y'),
        neighborhood,
        algorithm,
        states.length,
      )
      console.log('step for matrix')
      this.set({ matrix: step(matrix, options) })
    }

    this.set({ updateMatrix })

    const initLoop = () => {
      if (this.get('running')) {
        updateMatrix()
      }
    }

    const rotateHSLColor = () => {
      const backgroundColor = this.get('backgroundcolor')
      const backgroundcolor = toHSL(
        rotateHue(
          extractHSLColorComponents(backgroundColor)
          , -0.5
        )
      )
      this.set({ backgroundcolor })
    }

    setInterval(() => rotateHSLColor(), 100)

    this.set({ loopHandler: setInterval(initLoop, this.get('interval')) })

    console.log('constructor')
    console.log(this.constructor.loopHandler)
    // this.set({ loopHandler: setInterval( this.get('updateMatrix'), this.get('interval')) });
  },

  ondestroy () {
    clearInterval(this.interval)
  },

  data () {
    const field = { matrix: [] }

    return {
      backgroundcolor,
      running: false,
      loopHandler: null,
      interval: 1,
      X: 64,
      Y: 64,
      gap: 1,
      cellsize: 15,
      matrix: [],
      field
    }
  },
  computed: {
    backgroundcolor: (backgroundcolor) => backgroundcolor,
    gap: (gap) => parse(gap),
    field: (X, Y, cellsize, gap, matrix) => {
      return createField(states, matrix, X, Y, cellsize, gap)
    },
    width: (cellsize, gap) =>
      spacing(parse(cellsize), parse(gap)),
    height: (cellsize, gap) =>
      spacing(parse(cellsize), parse(gap)),
    canvas: (cellsize, X, Y, gap) =>
      canvasParams(parse(cellsize), parse(X), parse(Y), parse(gap)),
    X: X => parse(X),
    Y: Y => parse(Y),
    running: function (running) {
      if (running) {
        console.log('starting')
      } else {
        console.log('stopping')
      }
      return running
    }
  },
  components: {
    FieldDebug
  },
  methods: {
    click: function ({x, y}) {
      console.log(`clicked on x: ${x} y: ${y}`)
      const matrix = this.get('matrix')
      const dimension = { X: this.get('X'), Y: this.get('Y') }
      this.set({
        matrix:
        cellstate(
          matrix,
          dimension,
          { x, y },
          state => (state + 1) % states.length
        )
      })
    },
    next: function () {
      const next = this.get('updateMatrix')
      next()
    },
    save: function () {
      saveMatrixState(this)
    },
    load: function () {
      loadMatrixState(this)
    }
  }
}
</script>
