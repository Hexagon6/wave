<svg class="overflow-visible">
  <g>
    <rect
      width="{{canvas.width}}"
      height="{{canvas.height}}"
      x="{{canvas.x}}"
      y="{{canvas.y}}"
      style="fill:{{canvas.background}}"
    />
  {{#each matrix as row, i}}
    {{#each row as cell, j}}
      <rect
        width="{{width}}" height="{{height}}"
        x="{{cell.x + gap}}" y="{{cell.y + gap}}"
        id="cell{{i}}x{{j}}" style="fill:{{cell.color}}"
      />
    {{/each}}
  {{/each}}
  </g>
</svg>
<div class="debug">
  <div>
    <label>cellsize<input bind:value="cellsize" value="{{cellsize}}" maxlength="3" /></label>
    <button on:click="plus('cellsize')" value="+" >+</button>
    <button on:click="minus('cellsize')" value="-" >-</button>
  </div>
  <div>
    <label>gap<input bind:value="gap" value="{{gap}}" maxlength="3"/></label>
    <button on:click="plus('gap')" value="+" >+</button>
    <button on:click="minus('gap')" value="-" >-</button>
  </div>
  <div class="coordinate-inputs">
    <input bind:value="x" value="{{x}}" maxlength="2" />
    <div>x</div>
    <input bind:value="y" value="{{y}}" maxlength="2" />
  </div>
  <div>
    <ul>
      <li><b>computed values of field</b></li>
      <li>cellsize: [{{field.cellsize}}]</li>
      <li>x: {{field.x}}</li>
      <li>y: {{field.y}}</li>
      <li>gap: {{field.gap}}</li>
    </ul>
    <ul>
      <li><b>other computed values</b></li>
      <li>width: {{width}}</li>
      <li>width: {{height}}</li>
    </ul>
  </div>
</div>
<style>
  .overflow-visible {
    overflow: visible;
  }
  .coordinate-inputs {
    display: flex;
  }
  .coordinate-inputs input {
    max-width: 30px;
    position: relative;
    top: -7px;
  }
  .debug {
    display: none;
  }
</style>
<script type="buble">
import {
  background,
  createField,
  randomField,
  colors
} from '../modules/matrix'

import {
  add,
  substract,
  parseUnsignedInt as parse,
  spacing,
} from '../modules/utils'

const frames = 12 // Hz

const field = {
  config: {
    x: 42,
    y: 42,
    cellsize: 16,
    gap: 2,
    interval: 1 / frames * 1000,
  }
}

const canvasParams = (cellsize, x, y, gap) => {
  return {
    background,
    width: cellsize * x + gap,
    height: cellsize * y + gap,
    x: 0,
    y: 0
  }
}

const spacing = (n, gap) => {
  const _n = parse(n)
  const _gap = parse(gap)
  const spacing = (_gap) ? _n - _gap : _n
  return (spacing > 0) ? spacing : 0
}

export default {
  oncreate () {
    const {interval} = field.config
    const freq = 1000 / interval
    console.log(`Running simulation at ~${freq} Hz`)
    this.interval = setInterval( () => {
      const _matrix = randomField(field.config.x, field.config.y)
      this.set({ _matrix });
    }, interval );
  },
  data () {
    const {x, y, cellsize, gap} = field.config
    const matrix = []

    return {
      x, y, gap, cellsize, matrix
    }
  },
  computed: {
    gap: (gap) => parse(gap),
    matrix: (x, y, cellsize, gap, _matrix) => {
      const matrix = (_matrix) ? _matrix : []
      return createField(colors, matrix, x, y, cellsize, gap)
    },
    field: (matrix, cellsize, x, y, gap) => {
      return {
        matrix,
        cellsize,
        x,
        y,
        gap
      }
    },
    width: (cellsize, gap) =>
      spacing(parse(cellsize), parse(gap)),
    height: (cellsize, gap) =>
      spacing(parse(cellsize), parse(gap)),
    canvas: (cellsize, x, y, gap) =>
      canvasParams(parse(cellsize), parse(x), parse(y), parse(gap))
  },
  methods: {
    plus: function (variable) {
      const _v = parse(this.get(variable))
      const res = add(_v, 1)
      this.set({ [variable]: res })
    },
    minus: function (variable) {
      const _v = parse(this.get(variable))
      const res = substract(_v, 1)
      this.set({ [variable]: res })
    }
  }
}
</script>
