<svg class="container overflow-visible">
  <g>
    <rect
      width="{{canvas.width}}"
      height="{{canvas.height}}"
      x="{{canvas.x}}"
      y="{{canvas.y}}"
      style="fill:{{canvas.background}}"
    />
  {{#each field as row, y}}
    {{#each row as cell, x}}
      <rect
        on:click="click({x, y})"
        :width :height
        x="{{cell.x + gap}}" y="{{cell.y + gap}}"
        id="cell{{x}}x{{y}}" style="fill:{{cell.color}}"
      />
    {{/each}}
  {{/each}}
  </g>
</svg>
<FieldDebug
  ref:debug
  :X
  :Y
  :cellsize
  :gap
  :width
  :height
/>
<style>
  svg {
    position: absolute;
    right: 800px;
  }

  .overflow-visible {
    overflow: visible;
  }

  .container {
    display: flex;
  }
</style>
<script type="buble">
import FieldDebug from './FieldDebug.html'

import {
  algorithm,
  background,
  createField,
  randomMatrix,
  step,
  cellstate,
  colors
} from '../modules/matrix'

import {
  parseUnsignedInt as parse,
  spacing,
} from '../modules/utils'

const frames = 0.03 // Hz

const canvasParams = (cellsize, x, y, gap) => {
  return {
    background,
    width: cellsize * x + gap,
    height: cellsize * y + gap,
    x: 0,
    y: 0
  }
}

export default {
  oncreate () {
    const updateMatrix = (x, y) =>
      this.set({
        matrix: randomMatrix(colors.length)(x, y)
      })
    this.refs.debug.observe('X', (X) => { this.set({ X }); updateMatrix(X, this.get('Y'))})
    this.refs.debug.observe('Y', (Y) => { this.set({ Y }); updateMatrix(this.get('X'), Y)})
    this.refs.debug.observe('height', (height) => this.set({ height }))
    this.refs.debug.observe('width', (width) => this.set({ width }))
    this.refs.debug.observe('cellsize', (cellsize) => this.set({ cellsize }))
    this.refs.debug.observe('gap', (gap) => this.set({ gap }))

    const interval = 1 / frames * 1000
    const freq = 1000 / interval
    console.log(`Running simulation at ~${freq} Hz`)

    this.interval = setInterval( () => {
      const dimension = { X: this.get('X'), Y: this.get('Y') }
      const neighborhood = [
        { dx: -1, dy: -1},
        { dx: -1, dy: 0},
        { dx: -1, dy: 1},
        { dx: 0, dy: -1},
        { dx: 0, dy: 1},
        { dx: 1, dy: -1},
        { dx: 1, dy: 0},
        { dx: 1, dy: 1},
      ]
      // console.log('step for matrix')
      const matrix = step(this.get('matrix'), {
        neighborhood, dimension, algorithm,
        states: colors.length })
      this.set({ matrix });
    }, interval );
  },

  ondestroy () {
    clearInterval( this.interval );
  },

  data () {
    const field = { matrix: [] }

    return {
      X: 64,
      Y: 64,
      gap: 1,
      cellsize: 15,
      matrix: [],
      field
    }
  },
  computed: {
    gap: (gap) => parse(gap),
    field: (X, Y, cellsize, gap, matrix) => {
      return createField(colors, matrix, X, Y, cellsize, gap)
    },
    width: (cellsize, gap) =>
      spacing(parse(cellsize), parse(gap)),
    height: (cellsize, gap) =>
      spacing(parse(cellsize), parse(gap)),
    canvas: (cellsize, X, Y, gap) =>
      canvasParams(parse(cellsize), parse(X), parse(Y), parse(gap)),
    X: X => parse(X),
    Y: Y => parse(Y),
  },
  components: {
    FieldDebug
  },
  methods: {
    click: function ({x, y}) {
      console.log(`clicked on x: ${x} y: ${y}`)
      const matrix = this.get('matrix')
      const dimension = { X: this.get('X'), Y: this.get('Y') }
      this.set({
        matrix:
        cellstate(
          matrix,
          dimension,
          { x, y },
          state => (state + 1) % colors.length
        )
      })
    }
  }
}
</script>
